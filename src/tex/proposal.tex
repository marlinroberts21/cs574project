\documentclass[letterpaper,11pt,twocolumn]{article}
\usepackage{geometry}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\title{CS574 Project Proposal}
\date{\today}
\hypersetup{
  pdfauthor={Kenny Ballou \& Marlin Roberts},
  pdftitle={Project Proposal},
  pdfkeywords={},
  pdfsubject={},
  pdflang={English}}
\author{Kenny Ballou \& Marlin Roberts}

\begin{document}

\maketitle{}
\tableofcontents{}

\section{Application}

We propose to examine the string constraint solving evaluation framework
located at: \url{https://github.com/BoiseState/string-constraint-counting}.
This codebase provides a framework for demonstrating the applicability of
various automata types used to represent symbolic strings in a string
constraint solving system.  It currently has implementations for the bounded,
acyclic and acyclic weighted automata types.

The major functionality requirement is for the framework to provide a
comparable set of outputs for the implemented automata.  This requires each
implementation of an automaton to perform operations in a comparable way that
matches the equivalent Java string operations.

A modified solver based on Java String Analyzer~(JSA)~\cite{strings2003} is
provided that can be used with any of the three automata types to solve various
benchmark constraints as well as a set of constraints obtained from analysis of
actual programs.  It can output satisfiability results as well as model count
results for comparing the accuracy of the automata models.

While the current codebase is largely compliant with the properties and
functionality identified, the instrumentation developed here could be used to
ensure that automata and automata factory classes developed in the future
adhere to the requirements of the framework.  With this in mind, we will try to
define properties on interfaces and abstract classes where possible.

\subsection{Metrics}

The approximate metrics of the application are shown table
~\ref{tab:app-metrics}.


\begin{table}[ht]\label{tab:app-metrics}
  \centering
  \begin{tabular}{lr}
    \toprule
    Source Lines of Code & \(\sim14,000\) \\
    Source Files         & \(\sim70\) \\
    Classes              & \(\sim70\) \\
    Methods              & \(\sim700\) \\
    \bottomrule
  \end{tabular}
  \caption{Application Metrics}
\end{table}

\subsection{Areas of Interest}

\subsubsection{Interface Instrumentation vs. Implemented Class Instrumentation}

The bounded and acyclic automata types are implemented through an automata
modeling framework used by the Java String Analyzer~(JSA)~\cite{strings2003},
while the acyclic weighted implementation does not.  One of the aspects of
validation we can examine is the effectiveness of instrumenting an interface
versus a fully implemented class.  The surrounding AutomatonModel class
contains an instance of an automaton and is the implementation of an abstract
class, while the automaton itself does not implement an interface other than
\texttt{serializable} and \texttt{cloneable}.  We may be able to introduce an
interface for the automaton classes that does not affect operation of the
program but allows us have better control and placement of the
instrumentation.

\subsubsection{Modeling Behaviors}

Some of the desired behaviors involve the modeled String operations. Since the
framework is meant to be used to model Java String operations, the modeled
operations should perform as their Java counterpart does.  For instance, Java
String operation \texttt{substring~(start, end)} has specific behaviors that
depend on the values of \texttt{start}, \texttt{end}, and the length of the
string.  Specifically:

\begin{itemize}
\item{The \texttt{start} index is included in the returned string.}
\item{The \texttt{end} index is excluded from the returned string.}
\item{If \texttt{start} or \texttt{end} is negative, greater than the length of
    the string, or \texttt{start} is greater than \texttt{end}, then an
    exception is thrown.}
\end{itemize}

Any new type of automaton is expected to model these behaviors accurately in
order to be comparable to other types.  Since strings are represented by
automata, it may be difficult to express these requirements using JML and
assertions, since we cannot examine the returned values as an actual string.
Examining these automata may require introducing methods that are side-effect
free.  Existing methods used to test returned results will need to be examined
carefully for side-effects.

\section{Proposal of Changes}

We propose the usage of several verification tools to verify and otherwise
implement fixes for the following properties.

\subsection{Properties}

The following property classes have been identified to be areas of program
criticallity.  For each of the classes, we describe the nature of the set of
properties and the type of the property class.  For state based properties, we
will use either \texttt{Java Assertions}~\cite{oracle-java-assertions} or
\texttt{OpenJML}~\cite{openjml}.  For sequence based properties, we will use
\texttt{JavaMOP}~\cite{javamop}.

\paragraph{Automata Binary Operations} Operations involving two automata can
only be performed on automata of the same type.  We count roughly \(10\)
instances of this property.  Since this property is specified around operations
and not a sequence of operations, this is a state snapshot property.

\paragraph{Automata Return Types} Automata that return Automata need to
return the correct type.  There are about \(10\) instances of this property
that will need to be verified.  This property is state based since it is
centered around individual automata operations.

\paragraph{Automata Operations} Automata should be \textit{minimized} before
operations occur.  Since this property is concerned with the ordering of
methods, this is a sequence property.

\paragraph{Automata Determinized Operations} Automata are required to be
\textit{determinized} before they are \textit{minimized}.  Automata operations
need to be in a proper order, therefore, this is a sequence property.

\paragraph{Automata Normalized Operations} Automata should be
\textit{normalized} before they are \textit{determinized}.  Similar to the
previous property, the automata operations need to be verified via sequential
means.

\paragraph{String Operation Properties} Operations need to match Java String
operation behaviors, where it can be tested.  For example,
\texttt{substring~(start, end)} has a certain behavior associated with
(\texttt{start > end}) that should be replicated. There are about \(10\) unique
instances of this property that will need to be verified.  Operation behavior
for certain argument values will have to be determined and written into
post-conditions of the operations.

\paragraph{Automata Types} Automata returned from operations should have certain
characteristics, if they can be tested in a side-effect-free way.  There are
about \(8\) unique instances of this property to be verified.

For example:

\begin{itemize}
\item{\texttt{concatenate}: \texttt{new.automata size >= original.automata
      size}}
\item{\texttt{substring}: \texttt{new.automata size <= original.automata size}}
\end{itemize}

Other candidates to be considered:

\begin{itemize}
\item{\texttt{union}}
\item{\texttt{intersection}}
\item{\texttt{insert}}
\item{\texttt{replace}}
\item{\texttt{delete}}
\item{\texttt{trim}}
\item{\texttt{reverse}}
\end{itemize}

\paragraph{Automata Trimming Operations} Automata are required to have dead states and epsilon
transitions removed before certain operations.

\paragraph{Solver/Timer Operations} Timers used by solvers should be started before stopped,
both before requesting the total run time.  Since this property is focusing on
the ordering of methods on timer objects, this is a sequential property.

\section{Conclusion}

The overall health of the String Constraint Counter framework will be better
off after the addition of these property verifications.  Furthermore, future
development can proceed with more confidence as the verification toolings can
aid in ensuring future additions maintain adherence to the specifications.

\nocite{*}
\bibliographystyle{plain}
\bibliography{references}

\end{document}
